---
title: "Code Checks"
---

## Understanding Code checks
Code Checks are an example of [**Metaprogramming**](https://en.wikipedia.org/wiki/Metaprogramming). SDF takes your SQL workspace, classifiers, and lineage and creates a rich information schema whenever you run `sdf describe``.

Code-checks are simply small SQL queries that run against this information schema and check for the existence of certain properties which you want to assure. Some examples of effective code checks are:

 - Check Data Privacy: Ensure all personally identifiable information (PII) is appropriately anonymized
 - Check Data Ownership: Guarantee every table has an owner (a staple of GDPR)
 - Check Data Quality: Prevent different currency types from combining in calculations (e.g. preventing Â£ + $ )

## Writing Your First Code Check
Let's write and modify a code check, starting with one of the sdf samples.

```shell
sdf new --sample hello
```
This sample contains a code-check and a commented out classifier. Each code-check has a name, description, an assertion, and a path to the SQL statement that will be executed against the information schema.

```yml
  code-checks:
    - name: Code Check
      description: >
        Ensure that there is no PII.name
      assert: not-exists
      path: checks/code_check.sql

```
To run the code-check, simply execute `sdf describe`. During describe, SDF runs all its static analysis on the workspace, creating lineage, metadata, and ultimately executing the code-checks.

Hurray! The code check passes.

But, carefully read the code-check. It queries for any column that contains PII.name and asserts that this query should be empty. But we never added the classifier in the first place!

```sql
SELECT
    DISTINCT c.t_name as "table_name",
    c.c_name as "column name",
    c.classifiers
FROM
    columns c
WHERE
    c.classifiers like '%PII.name%'
```

To add the classifier and change the behavior, uncomment the following classifier later in the workspace, run `sdf describe` and the code-check will now fail.
```yml
      # classifiers:
      #   - PII.name
```

## Modifying Classifiers
Let's fix this! We can apply an `md5()` hash to column_2 (the name column) to obfuscate it. This is called a **reclassification** since we are transforming one classifier into another.

Let's add a function block that attaches a reclassify statement to the built-in md5 function. In your workspace.sdf.yml create the following function block.

```yml
---
function:
  name: md5
  reclassify:
    - from: PII.name
```
Now, create a second table that uses the md5 function. 
In the same directory as *main.sql*, create *sink.sql* with the line
```sql
select md5(column_2) from main;
```
Update the *code_check.sql* with the following line `and c.t_name like '%.sink'`. It should now look like the check below.
Now, the code check specifically checks the *sink* table for the PII.name classifier.

```sql
SELECT
    DISTINCT c.t_name as "table_name",
    c.c_name as "column name",
    c.classifiers
FROM
    columns c
WHERE
    c.classifiers like '%PII.name%'
    and c.t_name like '%.sink'
```

Run `sdf describe` again and voila! All code checks pass. The source table has PII.name, the sink table does not. 

## Advanced Code Checks

 - To learn more about transforming classifiers across functions, see: [UDFs]
 - To learn more about the SDF internal information schema, see: [Information Schema]
