---
title: "Checks"
---

## Understanding Checks
Checks are an example of [**Metaprogramming**](https://en.wikipedia.org/wiki/Metaprogramming). SDF takes your SQL workspace, classifiers, and lineage and creates a rich information schema whenever you run `sdf compile`.

Checks are simply small SQL queries that run against this information schema and check for the existence of certain properties which you want to assure. Some examples of effective checks are:

 - Ensure Data Privacy: Ensure all personally identifiable information (PII) is appropriately anonymized
 - Ensure Data Ownership: Guarantee every table has an owner (a staple of GDPR)
 - Ensure Data Quality: Prevent different currency types from combining in calculations (e.g. preventing Â£ + $ )

## Writing Your First Check
Let's write and modify a check, starting with one of the sdf samples.

```shell
sdf new --sample hello_with_pii
```
```shell
cd tmp/ && $sdf new --sample hello_with_pii
```
This sample contains a check and a commented out classifier. Each check has a name, description, an assertion, and a path to the SQL statement that will be executed against the information schema.

```yml
  workspace:
		name: hello
		edition: 1.2
    defaults:
      dialect: presto
		includes:
			- path: src
        # ADD THE BELOW #
        - path: checks
          type: check
```
To run the check, simply execute `sdf check`. During compile, SDF runs all its static analysis on the workspace, creating lineage, metadata, and ultimately executing the checks.

```shell
cd tmp/hello_with_pii && yq e '(select(.workspace.includes != null) | .workspace.includes) += [{"path": "checks", "type": "check"}]' -i workspace.sdf.yml && $sdf check
```

Hurray! The check passes.

But, carefully read the check. 

```sql
SELECT
    DISTINCT c.table_name as "table_name",
    c.column_name as "column name",
    c.classifiers
FROM
    sdf.information_schema.columns c
WHERE
    c.classifiers like '%PII.name%'
```

It queries for any column that contains PII.name and asserts that this query should be empty. But we never added the classifier in the first place!

To add the classifier and change the behavior, uncomment the following classifier later in the workspace, run `sdf check` and the check will now fail.
```yml
table:
  name: main
  columns:
    - name: column_2
      # UNCOMMENT THE BELOW
      classifiers:
        - PII.name
```
Running `sdf check` again will result in a failed test. 

```shell
cd tmp/hello_with_pii && yq e '(select(.table.name == "main") | .table.columns[0].classifiers) = ["PII.name"]' -i workspace.sdf.yml && $sdf check || true
```

## Modifying Classifiers
Let's fix this failing check! We can apply an `md5()` hash to column_2 (the name column) to obfuscate it. This is called a **reclassification** since we are transforming one classifier into another.

Let's add a function block that attaches a reclassify statement to the built-in md5 function. In your `workspace.sdf.yml` create the following function block.

```yml
---
function:
  name: md5
  reclassify:
    - from: PII.name
```
Now, create a second table that uses the md5 function. 
In the same directory as *main.sql*, create *sink.sql* with the line
```sql
select md5(column_2) from main;
```
Update the *code_check.sql* with the following line `and c.table_name like '%.sink'`. It should now look like the check below.
Now, the Check specifically checks the *sink* table for the PII.name classifier.

```sql
SELECT
    DISTINCT c.table_name as "table_name",
    c.column_name as "column name",
    c.classifiers
FROM
    columns c
WHERE
    c.classifiers like '%PII.name%'
    and c.table_name like '%.sink'
```

Run `sdf check` again and voila! All checks pass. The source table has PII.name, the sink table does not. 

## Advanced Checks

 - To learn more about transforming classifiers across functions, see: [UDFs](/guide/udf)
 - To learn more about the SDF internal information schema, see: [Information Schema](/reference/sdf-information-schema)
